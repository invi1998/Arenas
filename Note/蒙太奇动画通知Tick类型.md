# 蒙太奇动画通知Tick类型

在UE5的动画蒙太奇（Animation Montage）中，动画通知（Animation Notify Event）的 **Event** 属性下的 **蒙太奇Tick类型（Montage Tick Type）** 提供了两种选择：**"已排队（Queued）"** 和 **"分支点（BranchingPoint）"**。它们决定了通知在蒙太奇播放过程中的执行时机和方式，这对于动画与游戏逻辑的同步至关重要。

**Qeued和BranchingPoint**

AnimInstance上本身就有动画通知，蒙太奇上也可以额外添加动画通知，注意动画通知的TickType有**Qeued和BranchingPoint**两种。 Queued：通知触发时先被缓存起来，动画evaluate结束后一起触发，性能更好 BranchingPoint：通知触发时立即执行，用于做修改播放position等操作 添加slot

下面是它们的区别：

| 特性         | 已排队 (Queued)                                              | 分支点 (BranchingPoint)                                      |
| :----------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **触发时机** | 在蒙太奇的**下一帧更新时**处理                               | 在动画评估的**当前帧立即**执行                               |
| **执行顺序** | 按顺序排队，在常规的蒙太奇更新循环中处理                     | 立即触发，可能会打断当前帧的一些处理逻辑                     |
| **确定性**   | 相对较高，总在帧更新时发生                                   | 非常高，严格依赖于动画帧，适合需要高度同步的场景             |
| **性能影响** | 轻微，因为分布在帧更新中                                     | 可能轻微，因为立即执行，但大量使用可能增加单帧负载           |
| **适用场景** | 对执行时机不苛刻的事件（如播放非关键音效、触发简单的粒子效果） | 对时机要求**极其严格**的事件（如攻击伤害判定框生成、武器轨迹匹配、精确的帧事件同步、连招输入窗口判断） |

### 🌀 深入了解“已排队 (Queued)”

“已排队”模式的通知会被添加到**一个队列中**，并在**蒙太奇的下一帧更新 tick** 时**按顺序处理**。这意味着它们的执行时机与蒙太奇的帧率基本保持一致。

*   **优点**：执行时机相对 predictable（可预测），不会严重破坏当前帧的执行流。
*   **缺点**：由于需要等待下一帧更新，理论上会有**极短暂的延迟**（通常是一帧的时间），对于要求绝对精确帧同步的操作来说可能不够及时。
*   **典型用途**：播放一些对精确时机要求不高的音效、触发简单的粒子效果、设置一些动画状态参数等。

### ⚡ 深入了解“分支点 (BranchingPoint)”

“分支点”模式的设计目标就是**为了实现极致的同步精度**。它会在动画评估到精确的指定帧时**立即触发**通知，而不会等待蒙太奇的常规更新循环。

*   **优点**：提供了**最高的时机精确度和确定性**，确保游戏逻辑在 exactly 正确的动画帧被执行。这对于需要与动画帧完美匹配的操作至关重要。
*   **缺点**：因为会立即执行，**可能会略微干扰当前帧的处理流程**。如果在同一帧有大量的 "BranchingPoint" 通知，可能会带来轻微的性能波动。
*   **典型用途**：
    *   在攻击动画的特定帧**生成武器伤害判定框**（确保攻击命中的时机与动画视觉效果完全吻合）。
    *   **武器轨迹同步**（例如刀光拖尾效果必须在武器挥到特定位置时生成）。
    *   在连招系统中，**判断玩家输入窗口**（如在动画第X帧到Y帧之间输入才能成功触发下一段连招）。
    *   任何需要**与动画帧事件进行严格同步**的游戏逻辑。

### 💡 如何选择？

选择哪一种类型，主要取决于你的游戏逻辑对**时机精确度的要求**：

*   如果你的通知事件**对发生的具体帧数不是极端敏感**，稍微延迟一帧也能接受（例如一些环境音效、非关键性的视觉效果），那么使用 **"已排队 (Queued)"** 即可，它对流程的干扰更小。
*   如果你的通知事件**必须发生在动画的特定一帧**，任何延迟都会导致问题（例如攻击判定、格挡判定、精确的位移同步等），那么务必选择 **"分支点 (BranchingPoint)"**。

### 🔍 背后的原理（进阶理解）

根据搜索结果，动画通知的处理主要在 `UAnimInstance::TriggerAnimNotifies` 函数中完成。每一帧，引擎会收集所有需要触发的通知（包括 AnimNotify 和 AnimNotifyState）。“已排队”的通知会在这个统一的帧更新流程中被处理。而“分支点”则更像一个特殊通道，旨在绕过可能的队列等待，力求在第一时间被处理，以满足苛刻的同步需求。

### 注意事项

*   **性能考量**：虽然单个通知的影响很小，但在一个蒙太奇中或同时在多个角色上使用大量的 "BranchingPoint" 通知时，需注意其对性能的潜在影响，尤其是在同一帧触发多个时。
*   **网络复制**：如果你的游戏是多人的，需要注意的是动画通知的触发默认可能在**客户端和服务器上都会执行**。你要确保通知中的逻辑在网络环境下是安全的，或者根据需要设置其是否在专有服务器上触发。
*   **顺序不保证**：对于多个连续的 `AnimNotifyState`，引擎**不保证**它们的 `NotifyEnd` 和 `NotifyBegin` 会按照严格的顺序交错执行。例如两个相邻的NotifyState A和B，其执行顺序可能是 `A.Begin -> B.Begin -> A.End -> B.End`。设计逻辑时不应依赖其严格的顺序。

